* Diseño de Interfaces Web - Presentación
- Ciclo Formativo: *Desarrollo de Aplicaciones Web*
- Profesor: *Pedro Prieto Alarcón*

** Descripción del curso
** Requisitos previos
** Contenidos
** Scrum
Scrum es un marco de trabajo en grupo orientado a la realización de tareas en cortos períodos de tiempo por grupos pequeños (equipos de 4 a 8 personas, aproximadamente).

Vamos a integrar la filosofía Scrum en las prácticas que haremos a partir de ahora. En este apartado puedes consultar la información relacionada con Scrum y la adaptación *EduScrum* que utilizaremos en clase.

*** EduScrum
Página principal: http://eduscrum.nl/en/
Guía EduScrum (lectura *obligatoria*): http://eduscrum.nl/en/links
*** Filosofía y normas
La adopción de este estilo de trabajo conlleva una serie de responsabilidades que los alumnos tienen que aceptar:
- El trabajo se realizará en equipos de trabajo de cuatro personas.
- Los equipos son *autoorganizados*. El profesor (/product owner/) especifica *qué* se debe hacer y el equipo define el *cómo*.
- La nota de cada trabajo se puntúa a *nivel de grupo*, no de manera individual. Por tanto, los miembros del equipo deben tener un *compromiso* con los otros miembros. Este compromiso se traduce en una serie de *responsabilidades*:
  - Cada miembro debe trabajar al mismo nivel que sus compañeros.
  - Los miembros del equipo se comprometen a *asistir a clase* regularmente para participar del trabajo y las reuniones diarias que se realicen. Por supuesto, las faltas justificadas se aceptan naturalmente.
  - *Transparencia*. El trabajo realizado por cada miembro del equipo *estará visible* en la hoja de planificación del grupo. Dichas hojas estarán colgadas de las paredes de la clase de manera que cualquiera pueda ver el trabajo que se ha realizado y que se está realizando.
  - *Colaboración*. Uno de los objetivos que se persiguen con esta filosofía es fomentar la colaboración tanto *dentro del equipo* como *entre los distintos equipos* de trabajo.
  - *Respeto*. Las relaciones que se produzcan dentro de los equipos estarán basadas en el respeto. Cada persona es diferente y tiene diferentes capacidades, por lo que se asume que en determinados momentos unos miembros del equipo aportarán más que otros.
  - *Aprendizaje*. El objetivo más importante de este estilo de trabajo es que cada alumno alcance los *objetivos de aprendizaje* establecidos para cada proyecto.
- Esta manera de trabajar está basada en /inspect and adapt/: es decir, *analizar y adaptarse*. Cada ciclo de trabajo termina con una *retrospectiva* en la que se analizan los puntos fuertes y débiles para mejorar de cara al futuro.
*** Sprint
Un /sprint/ es un marco temporal definido a priori que agrupa un *conjunto de actividades, materiales de aprendizaje y eventos* que tiene como finalidad adquirir unos determinados *objetivos de aprendizaje*.

Al terminar el sprint el equipo de trabajo debe proporcionar un producto válido de acuerdo con unos criterios (/Definition of Done/). Además, cada miembro del equipo debe haber alcanzado los objetivos de aprendizaje previstos.
*** Scrum Master
El Scrum Master es el encargado de garantizar que el proceso se realiza correctamente (reuniones, etc.). Es además el encargado de *colgar la hoja de planificación* al comienzo de cada clase y de retirarla al final de la misma.
*** Lista de requerimientos (/Product Backlog/)
El /Product Backlog/ es una lista ordenada de elementos denominados *historias*. Cada historia puede ser realizada de manera independiente y su terminación contribuye a alcanzar los objetivos de aprendizaje establecidos para el sprint.

Las historias pueden considerarse tareas independientes, aunque algunas de ellas serán demasiado grandes y deberán ser subdivididas por el equipo de trabajo.
*** Reunión de planificación
Tiene una duración de dos horas. En ella se realizan las siguientes tareas:
- Asignación de equipos.
- Explicación del proyecto.
- Creación del *nombre del equipo*.
- Creación de la hoja de seguimiento.
- Planificación del trabajo (generación de la *lista de tareas*).
- Estimación de las tareas.

La *lista de tareas* se genera a partir del /Product Backlog/. Cada equipo puede decidir si cada elemento del /Product Backlog/ se convierte en una tarea o si se *divide* en tareas más pequeñas.

Cada tarea se anotará en un /post-it/. A continuación se asignará una *estimación horaria* a cada tarea. Así podrá contabilizarse el *número de horas totales estimadas* que necesitará el proyecto. Como referencia puede tomarse la duración del sprint sin incluir la reunión de planificación, demo y retrospectiva.

Al *finalizar* esta reunión el equipo de trabajo debe explicar al /product owner/ (profesor) un *resumen* de las decisiones tomadas y las estrategias adoptadas para abordar el proyecto.

*** La hoja de planificación (/Scrum board/)
Cada equipo dispondrá de una hoja de 1x1 metro para apuntar las *tareas* que se están o han realizado. La hoja tendrá *tres columnas*, un espacio para apuntar la /Definition of Done/ y un espacio para la gráfica /Burn Down Chart/.

Las tres columnas son:
- Por hacer
- En curso
- Terminada

La *lista de tareas* se genera a partir del /Product Backlog/ en la reunión de planificación. Inicialmente todas las tareas estarán en la columna /por hacer/ de manera ordenada (las de más arriba son más importantes).

Cuando un miembro del equipo asuma una tarea, cogerá el /post-it/ con la tarea correspondiente, *escribirá su nombre* en él y la pasará a la columna /por hacer/. Si la tarea no se acaba en la sesión de clase, al día siguiente *actualizará el número de horas que le quedan para terminarla* en el mismo post-it. De esta manera el Scrum Master podrá actualizar la gráfica Burn Down.

La lista de tareas no es cerrada. En todo momento pueden añadirse o eliminarse tareas en función de la evolución del trabajo. Por ejemplo, si algún miembro del equipo tiene que dedicar tiempo a asesorar a otro miembro del equipo puede crear la tarea correspondiente e indicar el número de horas que le ha llevado.

*** Burn Down Chart
Dentro de la hoja de planificación habrá espacio para la gráfica de /Burn Down/. Esta gráfica muestra en el eje X los días asignados al sprint y en el eje Y el número de horas *totales* (carga de trabajo) que quedan para terminar el proyecto.

El número de horas totales estimadas para el proyecto será determinado en la reunión de planificación por el equipo.

El *Scrum Master* será el encargado de *actualizar* esta gráfica en la *reunión diaria* con las estimaciones de horas pendientes que le facilite el resto de miembros del equipo.

*** Reunión diaria (Stand Up)
Al principio de cada clase, el equipo realizará una reunión diaria de *5 minutos de duración*. En ella cada miembro contestará a las siguientes preguntas:

- ¿Qué trabajo he aportado al equipo desde la última reunión?
- ¿Qué trabajo voy a hacer durante esta clase?
- ¿Qué impedimentos tengo para alcanzar mis objetivos?

El Scrum Master es el encargado de recordar al resto de miembros del equipo que tienen que realizar la reunión.

Además, el Scrum Master actualizará la /Burn Down Chart/ con las estimaciones que le proporcione el resto de compañeros.
*** Sprint Review (demo)
Tiene una duración de *dos horas*. En ella cada equipo expondrá sus desarrollos al resto de la clase. Cada equipo tendrá asignados 25 minutos.
*** Retrospectiva
Tiene una duración de *una hora*. En ella se realizarán las siguientes tareas:
- El equipo analizarán las estrategias de trabajo que han seguido para identificar qué puntos han funcionado bien y qué puntos pueden mejorar.
- Cada miembro del equipo analizará sus puntos fuertes y puntos débiles.
- El equipo decidirá qué debe dejar de hacer.

Tanto el equipo (colectivo) como cada miembro (individual) deberá responder a *4 preguntas*:
- ¿Qué fue bien?
- ¿Qué se puede mejorar?
- ¿Qué no se debe hacer más?
- ¿Qué voy a hacer (una cosa) para mejorar en el siguiente sprint?

** Tutorial básico de GIT
*** Descarga
Puedes descargar el cliente de GIT ~msysgit~ de https://github.com/msysgit/msysgit/releases. Debes seleccionar el archivo ~PortableGIT~.

Una vez descargado, descomprímelo a una carpeta y sitúa la carpeta en el directorio raíz del pendrive o disco duro portátil. Nombra esta carpeta como ~GIT~.
*** Ejecución de GIT
Para ejecutar GIT tienes dos opciones:
- Ejecutarlo simulando un entorno de *Linux Bash*. Para ello ejecuta ~git-bash.bat~.
- Ejecutarlo en un entorno de consola de *Windows*. Para ello ejecuta ~git-cmd.bat~.
Ejecutando cualquiera de las dos opciones se abrirá una consola de comandos. Desde allí se podrá ejecutar el comando ~git~ sin necesidad de realizar modificaciones en el sistema.

*OJO*: si se abre una consola normal del sistema no se podrá ejecutar GIT.
*** Configuración inicial
Para configurar GIT con nuestro usuario y correo electrónico hay que ejecutar:
#+BEGIN_SRC sh
  git config --global user.name "Nombre y apellido"
  git config --global user.email CORREO@ELECTRONICO
  git config --global core.editor notepad
  git config --global credential.helper cache
#+END_SRC

La última línea almacena el usuario y contraseña del usuario para no pedirlo cada vez que se realice un /push/.
*** Clonado de un repositorio
Para obtener una copia local de un repositorio remoto hay que ejecutar el comando:
#+BEGIN_SRC sh
git clone RUTA_AL_REPOSITORIO
#+END_SRC
La ~RUTA_AL_REPOSITORIO~ se obtiene de la página de GitHub del repositorio correspondiente.
*** Actualización de cambios generados en el repositorio
Si el repositorio original se modifica después de realizar el clonado inicial puede realizarse la actualización ejecutando:
#+BEGIN_SRC sh
git pull
#+END_SRC
*** Modificación de archivos locales
Después de realizar cambios en los archivos es posible visualizarlos mediante el comando:
#+BEGIN_SRC sh
git diff
#+END_SRC
*** Comprobación del estado
Para comprobar el estado del repositorio puede ejecutarse:
#+BEGIN_SRC sh
git status
#+END_SRC
*** Grabación de los cambios (add y commit)
Después de realizar cambios en el repositorio local se deben añadir con el siguiente comando:
#+BEGIN_SRC sh
git add .
#+END_SRC
De esta manera se añadirán los cambios realizados en los archivos y los archivos nuevos que se hayan creado. Es importante incluir el *punto* en el comando.

Por último, para guardar los cambios se debe ejecutar el comando:
#+BEGIN_SRC sh
git commit -m "Mensaje informativo"
#+END_SRC
De esta manera se guardarán los cambios realizados.
*** Guardado de los cambios en el repositorio remoto (push)
Para actualizar los cambios en el repositorio remoto (GitHub) se debe ejecutar)
#+BEGIN_SRC sh
git push
#+END_SRC
De esta manera se guardarán los cambios en el repositorio remoto de GitHub.
*** Guía completa
Para conocer Git en profundidad puedes consultar el libro publicado en este [[http://git-scm.com/book/es/v1/][enlace]].
** Flujo de trabajo para tareas individuales
1. Hacer un fork del repositorio del ejercicio correspondiente (dentro de https://github.com/interfacesweb). De esta manera se creará una copia del mismo en tu cuenta de GitHub personal.
2. Clonar el repositorio copiado en el equipo.
3. Modificar los archivos de acuerdo con el enunciado de la práctica (el enunciado se encuentra en el archivo ~README.org~ y puede leerse con el formato correcto en la página de GitHub).
4. Guardar los cambios realizados (~commit~) en el repositorio.
5. Subir (~push~) los cambios a GitHub.
6. Cuando se haya terminado, crear una ~pull request~ para que el profesor pueda comprobar los cambios.

Los cambios subidos al repositorio personal pueden visualizarse automáticamente en ~USUARIO.github.io/EJERCICIO~. Esto se consigue utilizando la tecnología de [[https://pages.github.com/][Páginas de GitHub]].
** Flujo de trabajo GIT para Scrum
A continuación se muestra un ejemplo de flujo de trabajo de Git para grupos. Existen muchas otras posibilidades, pero considero que ésta es de las que menos problemas pueden presentar. No obstante, si el equipo de desarrollo considera más adecuado utilizar otro método podrá hacerlo sin ningún problema.

Puedes consultar más información sobre el flujo de trabajo utilizando ramas en [[http://git-scm.com/book/zh/v2/Git-Branching-Branching-Workflows][este enlace]].

Este flujo de trabajo está basado en *repositorios compartidos* (/shared repositories/), donde todos los miembros del equipo de desarrollo tienen permisos para realizar cambios (pueden hacer /push/). 

Para evitar la aparición de conflictos, cada usuario realizará sus cambios en una *rama* distinta. De esta manera los cambios que haga un usuario no afectarán al resto. Una vez *finalizado el trabajo*, el usuario *incorporará* los cambios realizados en su rama a la *rama principal* (/merge/).

*IMPORTANTE*. En todos los comandos se considera que la rama de trabajo principal es /master/. En algunos proyectos la rama principal deberá ser /gh-pages/ para que los cambios se muestren en github.io. Si es el caso, se deberá reemplazar /master/ por /gh-pages/.

*** Actualizar origen
#+BEGIN_SRC sh
git pull origin master
#+END_SRC

*** Crear rama para el trabajo personal
El siguiente código crea una rama nueva con el nombre /nombre_rama/ y la selecciona para trabajar. Todos los cambios que se realicen después afectarán sólo a la rama de trabajo, no a la rama principal.
#+BEGIN_SRC sh
git checkout -b nombre_rama
#+END_SRC
  
*** Trabajar
add - commit, add - commit, add - commit,...

Subir cambios:
#+BEGIN_SRC sh
git push origin nombre_rama
#+END_SRC

Cuando se desee, y especialmente al terminar la tarea completamente, actualizar de nuevo con los cambios de los demás (incorporar los cambios que se hayan subido a la rama principal por otros miembros del equipo):
#+BEGIN_SRC sh
git fetch origin
git merge origin/master
#+END_SRC

Arreglar conflictos si aparecen (habrá que modificar los ficheros en conflicto, guardar los cambios y hacer un commit nuevo).

Por último, volver a subir la rama con los cambios:
#+BEGIN_SRC sh
git push origin nombre_rama
#+END_SRC

*** Crear /pull request/    
Al terminar, con todos los cambios de la rama subidos a Github, crear una *pull request* desde GitHub. Para ello se seleccionará la rama con los cambios y se realizará una /pull request/ desde ella. De esta manera todos los miembros del equipo recibirán un aviso con la notificación de que hay cambios nuevos que se van a incorporar a la rama principal.

*** Inspeccionar y comentar /pull request/ (opcional)
Opcionalmente, los miembros del equipo pueden inspeccionar y comentar la /pull request/.

*** Aceptar y hacer el /merge/ del /pull request/
Desde GitHub, aceptar la /pull request/ o seguir las instrucciones para corregir conflictos. A continuación, hacer el /merge/ de la rama en cuestión.

*** Borrar la rama (desde GitHub)
Al hacer el /merge/ desde GitHub se pregunta si se desea borrar la rama. Si este paso se olvida puede volver a realizarse accediendo a la /pull request/ correspondiente.

*** Borrar la rama local
Ojo, sólo cuando estemos seguros de que los cambios se han integrado en Github.
#+BEGIN_SRC sh
  git checkout master
  git pull origin master
  git branch -D nombre_rama
#+END_SRC
  
 
